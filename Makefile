# Global makefile configuration for local and pipeline
# Be careful when adjusting defaults since the pipeline might use them!

# Helper
comma:= ,
empty:=
space:= $(empty) $(empty)

# Detect OS
OS := $(shell uname -s | tr '[:upper:]' '[:lower:]')

# Detect and normalize architecture
ARCH := $(shell uname -m)
ifeq ($(ARCH), aarch64)
    ARCH := arm64
endif
ifeq ($(ARCH), x86_64)
    ARCH := amd64
endif

# If a file named ".makevaroverrides.env" exists in the project root, it will be included and its variables exported for project specific variable overrides
ifneq (,$(wildcard .makevaroverrides.env))
    include .makevaroverrides.env
    export $(shell sed -n 's/^\([A-Za-z_][A-Za-z0-9_]*\)=.*/\1/p' .makevaroverrides.env)
endif

# =============== NAME namings and targets ===============
# ========================================================

# The base name of the artifact which is being built.
# This will also be used as docker repository inside the configured registry.
NAME ?= $(shell echo $(notdir $(shell pwd)) | tr '[:upper:]' '[:lower:]')
# The latest git tag or commit hash
VERSION ?= $(shell git describe --tags --exact-match 2>/dev/null || git rev-parse --short HEAD)

# =============== Build metadata ===============
# ==============================================

# List of space separated targets to build. Each target has the form <platform>/<architecture>
TARGETS ?= $(OS)/$(ARCH)
# Container registry where all artifacts of docker rules are pushed to
DOCKER_REGISTRY ?= registry.hub.docker.com
# Automatically generated by replacing spaces with commas
# Replace darwin and windows platform with linux since there should be no need for building on those platforms due to docker-desktop
DOCKER_PLATFORMS := $(patsubst windows/%, linux/%, $(patsubst darwin/%, linux/%, $(subst $(space),$(comma),$(TARGETS))))
# Set docker build cache strategy. Options: filesystem, registry
# For "filesystem" cache, the cache will be set to ./out/.buildx-cache
# For "registry" cache, the cache will be set to the $(DOCKER_REGISTRY)/cache/$(NAME)
DOCKER_CACHE ?= filesystem
ifeq ($(DOCKER_CACHE),filesystem)
    DOCKER_CACHE_TO := type=local,dest=./out/.buildx-cache
    DOCKER_CACHE_FROM := type=local,src=./out/.buildx-cache
else ifeq ($(DOCKER_CACHE),registry)
    DOCKER_CACHE_TO := type=registry,ref=$(DOCKER_REGISTRY)/cache/$(NAME)
    DOCKER_CACHE_FROM := type=registry,ref=$(DOCKER_REGISTRY)/cache/$(NAME)
endif
# Additional flags for docker build command
DOCKER_BUILD_FLAGS ?=
# Format of the output for i.e. test executions. Options: text, json, xml
FORMAT ?= text
# Override to 1 if you use CGO in your project (for i.e. linking against C libraries)
CGO_ENABLED ?= 0
# Path to the dockerfile to template
DOCKERFILE ?= Dockerfile
# Required for private repositories where go dependencies are pulled from
GOPRIVATE ?= dev.azure.com
# If only one docker-image is built (ideally for the current platform) it should be loaded into docker-deamon for further usage
LOAD_FLAG := $(shell if [ "$(words $(subst ,, ,$(TARGETS)))" -eq 1 ]; then echo "--load"; else echo ""; fi)


.PHONY: all lint-dep lint format coverage test build oras-push docker-build docker-lint docker-test docker-push docker-setup docker-login docker-temlate download template-version clean print-vars help

all: format lint test build

# =============== Testing ================
# ========================================

lint-dep: ## Install linting dependencies
	@echo "========== Performing lint-dep stage"
	@sh -c "(cd /tmp && go install github.com/jstemmer/go-junit-report@latest && go install github.com/axw/gocov/gocov@latest && go install github.com/AlekSi/gocov-xml@latest && go install github.com/golangci/golangci-lint/cmd/golangci-lint@latest)"

lint: lint-dep ## Lint Golang files
	@test -f .golangci.yaml || { echo ".golangci.yaml file is missing"; exit 1; }
	@echo "========== Performing lint stage"
	@$(shell go env GOPATH)/bin/golangci-lint -c .golangci.yaml run

format: ## Go-format entire project
	@echo "========== Performing format stage"
	@gofmt -s -w ./

coverage: download ## Run coverage report for the project. Output format can be set via FORMAT=text|json|xml
	@echo "========== Performing coverage stage"
ifeq ($(FORMAT),text)
	@go test -coverprofile=cover.out ./...
endif
ifeq ($(FORMAT),json)
	@go test -coverprofile=cover.out ./... && gocov convert cover.out
endif
ifeq ($(FORMAT),xml)
	@go test -coverprofile=cover.out ./... && gocov convert cover.out | gocov-xml | tee coverage.xml
endif

test: download ## Run all tests of the project. Output format can be set via FORMAT=text|json|xml
	@echo "========== Performing test stage"
ifeq ($(FORMAT),text)
	@go test ./...
endif
ifeq ($(FORMAT),json)
	@go test -json -v ./... | tee report.json
endif
ifeq ($(FORMAT),xml)
	@go test -v ./... | go-junit-report | tee report.xml
endif

# =============== Building Binary ===============
# ===============================================

build: download template-version ## Build binaries for all TARGETS specified
	@echo "========== Performing build stage"
	@for target in $(TARGETS); do \
		GOOS=$$(echo $$target | cut -d'/' -f1); \
		GOARCH=$$(echo $$target | cut -d'/' -f2); \
		echo "========== Building for: platform=$$GOOS, architecture=$$GOARCH"; \
		CGO_ENABLED=$(CGO_ENABLED) GOOS=$$GOOS GOARCH=$$GOARCH \
		go build -v -o ./out/$(NAME)-$$GOOS-$$GOARCH ./cmd; \
	done

oras-push: docker-login ## Push built binaries into container registries via oras cli
	@echo "========== Performing oras-push stage"
	@for target in $(TARGETS); do \
		GOOS=$$(echo $$target | cut -d'/' -f1); \
		GOARCH=$$(echo $$target | cut -d'/' -f2); \
		echo "========== Pushing for: platform=$$GOOS, architecture=$$GOARCH"; \
		(cd ./out && oras push $(DOCKER_REGISTRY)/$(NAME):$(VERSION)-$$GOOS-$$GOARCH ./$(NAME)-$$GOOS-$$GOARCH); \
	done

# =============== Building Docker ===============
# ===============================================

docker-build: docker-setup docker-template ## Build docker images via buildx for all TARGETS specified. Multi-Stage docker build assumed.
	@echo "========== Performing docker-build stage"
	@echo "========== Building Docker image for platforms: $(DOCKER_PLATFORMS)"

	docker buildx build \
		--progress=plain \
		--platform $(DOCKER_PLATFORMS) \
		-t $(DOCKER_REGISTRY)/$(NAME):$(VERSION) \
		-f ./out/Dockerfile.templated \
		--cache-to=$(DOCKER_CACHE_TO) \
        --cache-from=$(DOCKER_CACHE_FROM) \
		--build-arg PAT=$(PAT) \
		--build-arg NAME=$(NAME) \
		--build-arg VERSION=$(VERSION) \
		--build-arg CGO_ENABLED=$(CGO_ENABLED) \
		$(DOCKER_BUILD_FLAGS) \
		$(LOAD_FLAG) \
		.

		@echo "========== Successfully built docker tag: $(DOCKER_REGISTRY)/$(NAME):$(VERSION)"

docker-lint: ## Run lint stage inside docker container
	@echo "========== Performing docker-test stage"
	$(MAKE) docker-build DOCKER_BUILD_FLAGS="--target=lint"

docker-test: ## Run test stage inside docker container
	@echo "========== Performing docker-test stage"
	$(MAKE) docker-build DOCKER_BUILD_FLAGS="--target=test"

docker-push: docker-build ## Push docker images via buildx for all TARGETS specified. Multi-Stage docker build assumed.
	@echo "========== Performing docker-push stage"
	@echo "Building Docker image for platforms: $(DOCKER_PLATFORMS)"

	docker buildx build \
		--progress=plain \
		--platform $(DOCKER_PLATFORMS) \
		-t $(DOCKER_REGISTRY)/$(NAME):$(VERSION) \
		-f ./out/Dockerfile.templated \
		--cache-to=$(DOCKER_CACHE_TO) \
        --cache-from=$(DOCKER_CACHE_FROM) \
		--build-arg PAT=$(PAT) \
		--build-arg NAME=$(NAME) \
		--build-arg VERSION=$(VERSION) \
		--build-arg CGO_ENABLED=$(CGO_ENABLED) \
		--push \
		.

	@echo "========== Successfully pushed docker tag: $(DOCKER_REGISTRY)/$(NAME):$(VERSION)"

# =============== Setup & Helper ===============
# ==============================================

docker-setup: docker-login ## Setup docker buildx for multi-arch builds
	@if [ -z "$(PAT)" ]; then \
		echo "Error: The environment variable PAT must be set and non-empty."; \
		exit 1; \
	fi
	@echo "========== Performing docker-setup stage"

	@echo "Setup buildx runner"
	@docker buildx inspect multiarch >/dev/null 2>&1 || docker buildx create --name multiarch --driver docker-container --use
	@docker buildx inspect --bootstrap
	# Setup build cache
	@mkdir -p ./out/.buildx-cache

docker-login: ## Login to all container registries
	@echo "========== Performing docker-login stage"
	@az acr login --name $(DOCKER_REGISTRY)

docker-template: ## Generate a Dockerfile with the updated ENTRYPOINT
	@echo "========== Performing docker-template stage"
	@test -f $(DOCKERFILE) || { echo "$(DOCKERFILE) file is missing"; exit 1; }
	@mkdir -p out
	@$(shell sed 's|"/<app>"|"/'"$(NAME)-$(VERSION)"'"|' $(DOCKERFILE) > ./out/Dockerfile.templated)

download: ## Download all dependencies for building and testing this project
	@echo "========== Performing download stage"
	@GOPRIVATE=$(GOPRIVATE) go mod download

template-version: ## Template version file before compilation to include build-context like the revision or tag into the NAME
	@echo "========== Performing template-version stage"
	@cp ./version/version.template ./version/version.go && sed -i 's/<version>/${VERSION}/g' ./version/version.go

clean: ## Remove build artifacts
	@echo "========== Performing clean stage"
	@rm -rf ./out
	@rm -f ./cover.out ./coverage.xml

print-vars: ## Print make variables in their final state
	@echo "========== Performing print-vars stage"
	@echo "OS: $(OS)"
	@echo "ARCH: $(ARCH)"
	@echo "NAME: $(NAME)"
	@echo "VERSION: $(VERSION)"
	@echo "TARGETS: $(TARGETS)"
	@echo "DOCKER_REGISTRY: $(DOCKER_REGISTRY)"
	@echo "DOCKER_PLATFORMS: $(DOCKER_PLATFORMS)"
	@echo "DOCKER_TAG_FLAGS: $(DOCKER_TAG_FLAGS)"
	@echo "DOCKER_CACHE_TO: $(DOCKER_CACHE_TO)"
	@echo "DOCKER_CACHE_FROM: $(DOCKER_CACHE_FROM)"
	@echo "FORMAT: $(FORMAT)"
	@echo "CGO_ENABLED: $(CGO_ENABLED)"
	@echo "GOPRIVATE: $(GOPRIVATE)"
	@echo "DOCKERFILE: $(DOCKERFILE)"
	@echo "LOAD_FLAG: $(LOAD_FLAG)"

help: ## Display this help screen
	@echo "This is a standard Makefile for building go projects with docker support. DO NOT CHANGE ITS CONTENT!"
	@echo "\nVariables can be changed in following overwrite order:"
	@echo "1. Place a file '.makevaroverrides.env' inside the project to override variables"
	@echo "2. Pass variables as arguments to make like 'make NAME=myapp' [target]"
	@echo "\nUsage: make [variable-overrides] [target]"
	@grep -h -E '^[a-zA-Z_-]+:.*?## .*$$' $(MAKEFILE_LIST) | awk 'BEGIN {FS = ":.*?## "}; {printf "\033[36m%-30s\033[0m %s\n", $$1, $$2}'
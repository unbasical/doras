# Global makefile configuration for local and pipeline
# Be careful when adjusting defaults since the pipeline might use them!

# Helper
comma:= ,
empty:=
space:= $(empty) $(empty)

# =============== Binary namings and targets ===============
# ==========================================================

# The base name of the artifact which is being built.
# This will also be used as docker repository inside the configured registry.
BINARY ?= $(shell echo $(notdir $(shell pwd)) | tr '[:upper:]' '[:lower:]')
# Targets to build. Each target has the form <platform>/<architecture>
TARGETS ?= linux/amd64 linux/arm64
# Container registry where all artifacts of docker rules are pushed to
DOCKER_REGISTRY ?= crcecumodulesshared001.azurecr.io
# Docker repository this project will be pushed to. Tag will be automatically appended during build
DOCKER_REPOSITORY := $(DOCKER_REGISTRY)/$(BINARY)
# Automatically generated by replacing spaces with commas
DOCKER_PLATFORMS := $(subst $(space),$(comma),$(TARGETS))
# Flag to configure if docker build should be pushed after completion. --push can be set to push the built image.
DOCKER_FLAGS ?= $(empty)

# =============== Versioning and build metadata ===============
# =============================================================

# The latest git tag or commit hash
VERSION ?= $(shell git describe --tags --exact-match 2>/dev/null || git rev-parse --short HEAD)
# Format of the output for i.e. test executions. Options: text, json, xml
FORMAT ?= text
# Override to 1 if you use CGO in your project (for i.e. linking against C libraries)
CGO_ENABLED ?= 0
# Path to the dockerfile to template
DOCKERFILE ?= Dockerfile


.PHONY: all lint format coverage test build docker docker-local-build docker-setup docker-temlate download template-version clean help

all: lint test build

# =============== Testing ================
# ========================================

lint: ## Lint Golang files
	@test -f .golangci.yml || { echo ".golangci.yml file is missing"; exit 1; }
	@echo "========== Performing lint stage"
	@golangci-lint -c .golangci.yml run

format: ## Go-format entire project
	@echo "========== Performing lint stage"
	@gofmt -s -w ./

coverage: download ## Run coverage report for the project. Output format can be set via FORMAT=text|json|xml
	@echo "========== Performing coverage stage"
ifeq ($(TEST_OUTPUT),text)
	@go test -coverprofile=cover.out ./...
endif
ifeq ($(TEST_OUTPUT),json)
	@go test -coverprofile=cover.out ./... && gocov convert cover.out
endif
ifeq ($(TEST_OUTPUT),xml)
	@go test -coverprofile=cover.out ./... && gocov convert cover.out | gocov-xml | tee coverage.xml
endif

test: download ## Run all tests of the project. Output format can be set via FORMAT=text|json|xml
	@echo "========== Performing test stage"
ifeq ($(TEST_OUTPUT),text)
	@go test ./...
endif
ifeq ($(TEST_OUTPUT),json)
	@go test -json -v ./... | tee report.json
endif
ifeq ($(TEST_OUTPUT),xml)
	@go test -v ./... | go-junit-report | tee report.xml
endif

# =============== Building ===============
# ========================================

build: download template-version ## Build binaries for all TARGETS specified
	@echo "========== Performing docker-template stage"
	@for target in $(TARGETS); do \
		GOOS=$$(echo $$target | cut -d'/' -f1); \
		GOARCH=$$(echo $$target | cut -d'/' -f2); \
		echo "========== Building for: platform=$$GOOS, architecture=$$GOARCH"; \
		CGO_ENABLED=$(CGO_ENABLED) GOOS=$$GOOS GOARCH=$$GOARCH \
		go build -v -o ./out/$(BINARY)-$$GOOS-$$GOARCH ./cmd; \
	done

docker: docker-setup docker-template ## Build and push docker images via buildx for all TARGETS specified. Multi-Stage docker build assumed.
	@echo "========== Performing docker stage"
	@echo "Building Docker image for platforms: $(DOCKER_PLATFORMS)"
	docker buildx build \
		--platform $(DOCKER_PLATFORMS) \
		-t $(DOCKER_REPOSITORY):$(VERSION) \
		-f ./out/Dockerfile.templated \
		--cache-to=type=local,dest=./out/.buildx-cache \
        --cache-from=type=local,src=./out/.buildx-cache \
		--build-arg PAT=$(PAT) \
		--build-arg BINARY=$(BINARY) \
		--build-arg VERSION=$(VERSION) \
		--build-arg CGO_ENABLED=$(CGO_ENABLED) \
		$(DOCKER_FLAGS) \
		.

docker-local-build: build docker-setup ## Build and push docker images via buildx for all TARGETS specified. Binaries are built local and are just copied in the final dockerfile.
	DOCKERFILE=$(DOCKERFILE).pipeline $(MAKE) docker-template
	@echo "========== Performing docker-local-build stage"
	@echo "========== Building Docker image for platforms: $(DOCKER_PLATFORMS)"
	docker buildx build \
		--platform $(DOCKER_PLATFORMS) \
		-t $(DOCKER_REPOSITORY):$(VERSION) \
		-f ./out/Dockerfile.templated \
		--cache-to=type=local,dest=./out/.buildx-cache \
        --cache-from=type=local,src=./out/.buildx-cache \
		--build-arg PAT=$(PAT) \
		--build-arg BINARY=$(BINARY) \
		--build-arg VERSION=$(VERSION) \
		--build-arg CGO_ENABLED=$(CGO_ENABLED) \
		$(DOCKER_FLAGS) \
		.

# =============== Setup ===============
# =====================================

docker-setup: ## Setup docker buildx for multi-arch builds
	@if [ -z "$(PAT)" ]; then \
		echo "Error: The environment variable PAT must be set and non-empty."; \
		exit 1; \
	fi
	@echo "========== Performing docker-setup stage"
	@docker buildx inspect multiarch >/dev/null 2>&1 || docker buildx create --name multiarch --driver docker-container --use
	@docker buildx inspect --bootstrap
	# Setup build cache
	@mkdir -p ./out/.buildx-cache

docker-template: ## Generate a Dockerfile with the updated ENTRYPOINT
	@echo "========== Performing docker-template stage"
	@test -f $(DOCKERFILE) || { echo "$(DOCKERFILE) file is missing"; exit 1; }
	@mkdir -p out
	@$(shell sed 's|"/<app>"|"/'"$(BINARY)-$(VERSION)"'"|' $(DOCKERFILE) > ./out/Dockerfile.templated)

download: ## Download all dependencies for building and testing this project
	@echo "========== Performing download stage"
	@go mod download
	@sh -c "(cd /tmp && go install github.com/jstemmer/go-junit-report@latest && go install github.com/axw/gocov/gocov@latest && go install github.com/AlekSi/gocov-xml@latest)"

template-version: ## Template version file before compilation to include build-context like the revision or tag into the binary
	@echo "========== Performing template-version stage"
	@cp ./version/version.template ./version/version.go && sed -i 's/<version>/${VERSION}/g' ./version/version.go

clean: ## Remove build artifacts
	@rm -rf ./out
	@rm -f ./cover.out ./coverage.xml

help: ## Display this help screen
	@grep -h -E '^[a-zA-Z_-]+:.*?## .*$$' $(MAKEFILE_LIST) | awk 'BEGIN {FS = ":.*?## "}; {printf "\033[36m%-30s\033[0m %s\n", $$1, $$2}'